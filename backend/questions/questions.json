[
  {
    "type": "mcq",
    "question": "Which of the following operations takes O(1) time in an array (unsorted)?",
    "options": ["Searching for an element", "Inserting at the end", "Deleting a specific element", "Inserting at the beginning"],
    "answer": "Inserting at the end",
    "difficulty": "easy",
    "points": 5,
    "topic": "arrays",
    "tags": ["time complexity", "insertion"],
    "explanation": "In an unsorted array, you can insert at the end in constant time without rearranging elements."
  },
  {
    "type": "mcq",
    "question": "What will be the output of the following code? int arr[5] = {1,2,3,4,5}; printf(\"%d\", *(arr + 3));",
    "options": ["2", "3", "4", "5"],
    "answer": "4",
    "difficulty": "easy",
    "points": 5,
    "topic": "c programming",
    "tags": ["pointer arithmetic", "arrays"],
    "explanation": "*(arr + 3) accesses the 4th element (0-based indexing), which is 4."
  },
  {
    "type": "mcq",
    "question": "What is the worst-case time complexity for inserting an element at a specific position in an array?",
    "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["time complexity", "insertion"],
    "explanation": "All elements after the position must be shifted to make space."
  },
  {
    "type": "mcq",
    "question": "Given an array sorted in ascending order, what is the best algorithm to search for an element?",
    "options": ["Linear Search", "Jump Search", "Binary Search", "Interpolation Search"],
    "answer": "Binary Search",
    "difficulty": "easy",
    "points": 5,
    "topic": "searching",
    "tags": ["binary search", "sorted array"],
    "explanation": "Binary Search gives O(log n) in sorted arrays."
  },
  {
    "type": "mcq",
    "question": "How many swaps are required to sort an array of size 'n' if the array is already sorted?",
    "options": ["0", "n", "n-1", "n/2"],
    "answer": "0",
    "difficulty": "easy",
    "points": 5,
    "topic": "sorting",
    "tags": ["already sorted", "swaps"],
    "explanation": "Already sorted => no swaps needed."
  },
  {
    "type": "mcq",
    "question": "If you double the size of a dynamic array every time it is full, what is the amortized time complexity of insertion?",
    "options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
    "answer": "O(1)",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic arrays",
    "tags": ["amortized analysis", "resizing"],
    "explanation": "Though resizing takes time, over many insertions, average cost per insertion is O(1)."
  },
  {
    "type": "mcq",
    "question": "Which one of the following algorithms cannot be used for searching an element in an unsorted array?",
    "options": ["Linear Search", "Binary Search", "Hashing", "None of the above"],
    "answer": "Binary Search",
    "difficulty": "easy",
    "points": 5,
    "topic": "searching",
    "tags": ["unsorted array", "binary search"],
    "explanation": "Binary Search only works for sorted data."
  },
  {
    "type": "mcq",
    "question": "If an array is rotated k times to the right, how can we find k efficiently in O(log n) time?",
    "options": ["Use Linear Search", "Find minimum element with modified Binary Search", "Use Merge Sort", "None"],
    "answer": "Find minimum element with modified Binary Search",
    "difficulty": "hard",
    "points": 15,
    "topic": "rotated arrays",
    "tags": ["binary search", "rotation"],
    "explanation": "In rotated sorted array, the minimum element tells about rotation."
  },
  {
    "type": "mcq",
    "question": "An array contains n elements, and all elements are distinct. What is the time complexity to find both maximum and minimum?",
    "options": ["O(n)", "O(2n)", "O(n log n)", "O(log n)"],
    "answer": "O(n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["max-min", "traversal"],
    "explanation": "A single traversal can find both max and min."
  },
  {
    "type": "mcq",
    "question": "If elements are inserted in a static array beyond its declared size, it causes:",
    "options": ["Segmentation Fault", "Stack Overflow", "Buffer Overflow", "Array Out of Bounds Error"],
    "answer": "Array Out of Bounds Error",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["array bounds", "runtime error"],
    "explanation": "Accessing memory beyond array bounds causes runtime errors."
  },
  {
    "type": "mcq",
    "question": "In a sorted array, how do you remove duplicates efficiently?",
    "options": ["Use a temporary array", "Use two-pointer approach", "Sort again", "Use HashMap"],
    "answer": "Use two-pointer approach",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["duplicate removal", "two-pointer"],
    "explanation": "Traverse with two pointers; avoid extra space."
  },
  {
    "type": "mcq",
    "question": "What is the space complexity of the Merge Sort algorithm on arrays?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "sorting",
    "tags": ["merge sort", "space complexity"],
    "explanation": "Merge Sort uses additional O(n) space for merging arrays."
  },
  {
    "type": "mcq",
    "question": "Which of the following statements about arrays in C is FALSE?",
    "options": ["Arrays are stored in contiguous memory locations.", "Size of array can be changed at runtime.", "Array index starts from 0.", "Array elements can be accessed randomly."],
    "answer": "Size of array can be changed at runtime.",
    "difficulty": "easy",
    "points": 5,
    "topic": "c programming",
    "tags": ["arrays", "static size"],
    "explanation": "In C, static arrays have fixed size."
  },
  {
    "type": "mcq",
    "question": "Accessing an element in an array using an invalid index leads to:",
    "options": ["Compilation Error", "Runtime Error", "Logical Error", "None"],
    "answer": "Runtime Error",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["runtime error", "invalid access"],
    "explanation": "It usually causes a segmentation fault or undefined behavior."
  },
  {
    "type": "mcq",
    "question": "Which data structure is most suitable for implementing a sparse array?",
    "options": ["2D Array", "Linked List", "Hash Map", "Stack"],
    "answer": "Hash Map",
    "difficulty": "hard",
    "points": 15,
    "topic": "data structures",
    "tags": ["sparse array", "hashing"],
    "explanation": "Sparse arrays can be efficiently represented using hashing (only storing non-zero elements)."
  },
  {
    "type": "mcq",
    "question": "Which is TRUE about array insertion at beginning?",
    "options": ["Always O(1)", "Always O(n)", "Always O(log n)", "None"],
    "answer": "Always O(n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["insertion", "time complexity"],
    "explanation": "Shifting elements rightward takes O(n) time."
  },
  {
    "type": "mcq",
    "question": "What is the maximum number of subarrays possible for an array of size n?",
    "options": ["n", "n(n+1)/2", "n^2", "n^2/2"],
    "answer": "n(n+1)/2",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["subarrays", "combinatorics"],
    "explanation": "Subarrays = (n * (n+1)) / 2."
  },
  {
    "type": "mcq",
    "question": "Which of the following can not be performed directly on arrays?",
    "options": ["Insertion at any index", "Deletion from any index", "Dynamic resizing", "Traversal"],
    "answer": "Dynamic resizing",
    "difficulty": "easy",
    "points": 5,
    "topic": "arrays",
    "tags": ["limitations", "static memory"],
    "explanation": "Arrays have fixed size once allocated."
  },
  {
    "type": "mcq",
    "question": "What would be the time complexity to find the majority element (more than n/2 times) using Boyer-Moore Voting Algorithm?",
    "options": ["O(n log n)", "O(n)", "O(log n)", "O(n^2)"],
    "answer": "O(n)",
    "difficulty": "hard",
    "points": 15,
    "topic": "arrays",
    "tags": ["majority element", "boyer-moore"],
    "explanation": "Boyer-Moore runs in linear time and constant space."
  },
  {
    "type": "mcq",
    "question": "When we copy an array of size n, what is the time complexity?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "arrays",
    "tags": ["copying", "time complexity"],
    "explanation": "Copying each element once takes O(n) time."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a valid array declaration in C?",
    "options": ["int arr[10];", "int arr[] = {1,2,3};", "int arr[5] = {1,2,3};", "int arr[-5];"],
    "answer": "int arr[-5];",
    "difficulty": "easy",
    "points": 5,
    "topic": "c programming",
    "tags": ["invalid declaration", "arrays"],
    "explanation": "Array size cannot be negative."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of finding the maximum element in an unsorted array?",
    "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "easy",
    "points": 5,
    "topic": "arrays",
    "tags": ["max element", "linear search"],
    "explanation": "You need to check each element once."
  },
  {
    "type": "mcq",
    "question": "Which operation is more efficient in a linked list than an array?",
    "options": ["Accessing an element by index", "Insertion at the beginning", "Binary search", "Accessing the last element"],
    "answer": "Insertion at the beginning",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["efficiency", "insertion"],
    "explanation": "Linked lists allow O(1) insertion at the beginning without shifting elements."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity to access the k-th element in a singly linked list?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(k log n)"],
    "answer": "O(n)",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["time complexity", "access"],
    "explanation": "You must traverse the list from the head to reach the k-th element."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a type of linked list?",
    "options": ["Singly linked list", "Doubly linked list", "Circular linked list", "Binary linked list"],
    "answer": "Binary linked list",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["types", "basics"],
    "explanation": "Binary linked list is not a standard linked list type."
  },
  {
    "type": "mcq",
    "question": "In a singly linked list, which pointer is present in each node?",
    "options": ["Only prev", "Only next", "Both prev and next", "Random"],
    "answer": "Only next",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["node structure"],
    "explanation": "Each node in a singly linked list contains data and a pointer to the next node."
  },
  {
    "type": "mcq",
    "question": "How do you detect a loop in a linked list efficiently?",
    "options": ["Use a counter", "Sort the list", "Use Floyd’s cycle detection", "Traverse twice"],
    "answer": "Use Floyd’s cycle detection",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["loop detection", "floyd"],
    "explanation": "Floyd’s algorithm uses two pointers to detect cycles with O(n) time and O(1) space."
  },
  {
    "type": "mcq",
    "question": "What is the best case time complexity to insert an element at the end of a singly linked list (with tail pointer)?",
    "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    "answer": "O(1)",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["insertion", "tail"],
    "explanation": "With a tail pointer, inserting at the end is constant time."
  },
  {
    "type": "mcq",
    "question": "What happens if we delete a node in a linked list without updating pointers correctly?",
    "options": ["List becomes empty", "Compilation error", "Memory leak or broken list", "All elements are deleted"],
    "answer": "Memory leak or broken list",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["deletion", "error"],
    "explanation": "Incorrect pointer update can disconnect nodes or cause memory leaks."
  },
  {
    "type": "mcq",
    "question": "Which of the following is true about doubly linked lists?",
    "options": ["They use more memory than singly linked lists", "Cannot be circular", "Faster insertion only at end", "They don't support deletion"],
    "answer": "They use more memory than singly linked lists",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["doubly linked list", "memory"],
    "explanation": "Doubly linked list has two pointers, requiring more memory."
  },
  {
    "type": "mcq",
    "question": "In a circular linked list, the last node points to:",
    "options": ["NULL", "Previous node", "Itself", "Head node"],
    "answer": "Head node",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["circular", "pointer"],
    "explanation": "Circular list’s last node links back to the first node (head)."
  },
  {
    "type": "mcq",
    "question": "What is the advantage of using a linked list over an array?",
    "options": ["Faster access by index", "Better cache locality", "Dynamic size and easy insertion/deletion", "Constant-time search"],
    "answer": "Dynamic size and easy insertion/deletion",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["advantages", "comparison"],
    "explanation": "Linked lists can grow or shrink dynamically and allow easy insertion/deletion."
  },
  {
    "type": "mcq",
    "question": "Which of the following is used to reverse a singly linked list efficiently?",
    "options": ["Recursion", "Stack", "Iteration with three pointers", "Binary search"],
    "answer": "Iteration with three pointers",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["reversal", "iteration"],
    "explanation": "Three pointers (prev, curr, next) are used to reverse a singly linked list iteratively."
  },
  {
    "type": "mcq",
    "question": "What does the head of a linked list represent?",
    "options": ["The tail node", "NULL", "The first node", "The last node"],
    "answer": "The first node",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["head", "structure"],
    "explanation": "Head points to the start (first node) of the linked list."
  },
  {
    "type": "mcq",
    "question": "Which of the following operations is not constant time for a linked list with head and tail pointers?",
    "options": ["Insert at head", "Insert at tail", "Delete last node", "Check if list is empty"],
    "answer": "Delete last node",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["operations", "time complexity"],
    "explanation": "To delete the last node, traversal is required in a singly linked list."
  },
  {
    "type": "mcq",
    "question": "How is memory allocation done for linked list nodes?",
    "options": ["Statically", "Dynamically using malloc or new", "Using arrays", "Predefined block"],
    "answer": "Dynamically using malloc or new",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["memory", "allocation"],
    "explanation": "Linked list nodes are dynamically allocated using malloc (C) or new (C++)."
  },
  {
    "type": "mcq",
    "question": "Which algorithm is used to find the middle of a linked list?",
    "options": ["Two-pointer (slow and fast)", "Binary search", "DFS", "BFS"],
    "answer": "Two-pointer (slow and fast)",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["middle node", "two pointer"],
    "explanation": "Fast pointer moves 2 steps, slow pointer moves 1 step to reach middle."
  },
  {
    "type": "mcq",
    "question": "What is the space complexity of a singly linked list with n nodes?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["space complexity", "nodes"],
    "explanation": "Each node requires memory for data and pointer, total O(n)."
  },
  {
    "type": "mcq",
    "question": "To delete a node in O(1) time (excluding tail), which of the following techniques is used?",
    "options": ["Copy next node data to current and delete next", "Shift data backward", "Use a dummy node", "Not possible"],
    "answer": "Copy next node data to current and delete next",
    "difficulty": "hard",
    "points": 15,
    "topic": "linked list",
    "tags": ["deletion", "trick"],
    "explanation": "This trick works by copying the next node’s value and bypassing it."
  },
  {
    "type": "mcq",
    "question": "Which is better for implementing undo functionality in editors?",
    "options": ["Array", "Linked list", "Stack", "Queue"],
    "answer": "Stack",
    "difficulty": "medium",
    "points": 10,
    "topic": "data structures",
    "tags": ["undo", "use case"],
    "explanation": "Stacks provide LIFO behavior, ideal for undo operations."
  },
  {
    "type": "mcq",
    "question": "Which traversal is not possible in singly linked list?",
    "options": ["Forward", "Reverse", "Head to tail", "None"],
    "answer": "Reverse",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["traversal", "limitation"],
    "explanation": "Singly linked list cannot be reversed without additional space or modification."
  },
  {
    "type": "mcq",
    "question": "Which of the following is required to delete the first node in a singly linked list?",
    "options": ["Tail pointer", "Previous node", "Head pointer", "Middle pointer"],
    "answer": "Head pointer",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["deletion", "first node"],
    "explanation": "Head pointer is used to remove and update the first node."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a disadvantage of linked lists compared to arrays?",
    "options": ["Memory overhead", "Random access", "Cache locality", "Complexity"],
    "answer": "Random access",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["disadvantages", "comparison"],
    "explanation": "Linked lists do not allow random access; arrays do."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of searching for an element in a singly linked list?",
    "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["searching", "time complexity"],
    "explanation": "You may need to traverse the entire list in the worst case."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a valid operation on a linked list?",
    "options": ["Insertion", "Deletion", "Traversal", "Sorting"],
    "answer": "Sorting",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["operations", "sorting"],
    "explanation": "Linked lists can be sorted, but it’s not a direct operation like insertion or deletion."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of reversing a linked list?",
    "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    "answer": "O(n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["reversal", "time complexity"],
    "explanation": "Each node is visited once, leading to O(n) time complexity."
  },    
  {
    "type": "mcq",
    "question": "Which of the following is not a type of tree?",
    "options": ["Binary Tree", "Binary Search Tree", "AVL Tree", "Circular Tree"],
    "answer": "Circular Tree",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["types", "basics"],
    "explanation": "Circular tree is not a standard tree type."
  },
  {
    "type": "mcq",
    "question": "What is the height of a complete binary tree with n nodes?",
    "options": ["log n", "n", "(log n) + 1", "(n - 1) / 2"],
    "answer": "(log n) + 1",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["height", "complete binary tree"],
    "explanation": "Height of a complete binary tree is log(n) + 1."
  },
  {
    "type": "mcq",
    "question": "In a binary search tree, which of the following is true?",
    "options": ["Left child < Parent < Right child", "Left child > Parent > Right child", "Parent < Left child < Right child", "None"],
    "answer": "Left child < Parent < Right child",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["binary search tree", "properties"],
    "explanation": "In a BST, left subtree nodes are less than the parent, and right subtree nodes are greater."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(log n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["searching", "balanced BST"],
    "explanation": "Balanced BST allows logarithmic time complexity for search operations."
  },
  {
    "type": "mcq",
    "question": "Which traversal method visits all nodes at the present depth level before moving on to nodes at the next depth level?",
    "options": ["Pre-order", "In-order", "Post-order", "Level-order"],
    "answer": "Level-order",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["traversal", "level order"],
    "explanation": "Level-order traversal uses a queue to visit nodes level by level."
  },
  {
    "type": "mcq",
    "question": "What is the maximum number of nodes in a binary tree of height h?",
    "options": ["h", "2^h - 1", "2^h", "h^2"],
    "answer": "2^h - 1",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["maximum nodes", "height"],
    "explanation": "A complete binary tree has maximum nodes equal to 2^h - 1."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a balanced tree?",
    "options": ["AVL Tree", "Red-Black Tree", "B-tree", "Binary Search Tree"],
    "answer": "Binary Search Tree",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["balanced trees", "BST"],
    "explanation": "BSTs are not necessarily balanced; AVL and Red-Black trees are."
  },            
    {
        "type": "mcq",
        "question": "What is the time complexity of inserting an element in a binary search tree?",
        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        "answer": "O(log n)",
        "difficulty": "medium",
        "points": 10,
        "topic": "trees",
        "tags": ["insertion", "BST"],
        "explanation": "In a balanced BST, insertion takes logarithmic time."
    },
    {
        "type": "mcq",
        "question": "Which of the following is not a property of a binary tree?",
        "options": ["Each node has at most two children", "Height of a binary tree is log(n)", "A binary tree can be empty", "All nodes have two children"],
        "answer": "All nodes have two children",
        "difficulty": "easy",
        "points": 5,
        "topic": "trees",
        "tags": ["properties", "binary tree"],
        "explanation": "Not all nodes in a binary tree need to have two children."
    },
  {
    "type": "mcq",
    "question": "In an undirected graph with n nodes and no self-loops, what is the maximum number of edges possible?",
    "options": ["n", "n(n-1)", "n(n-1)/2", "n²"],
    "answer": "n(n-1)/2",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["undirected", "max edges", "combinatorics"],
    "explanation": "Each pair of nodes can have at most one edge; undirected graphs count each edge once."
  },
  {
    "type": "mcq",
    "question": "Which of the following is FALSE for a tree?",
    "options": ["It is a connected graph", "It has no cycles", "It has exactly (n-1) edges", "It can have multiple parents for a node"],
    "answer": "It can have multiple parents for a node",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["tree", "properties"],
    "explanation": "In a tree, each node (except root) has exactly one parent."
  },
  {
    "type": "mcq",
    "question": "The time complexity of BFS (Breadth-First Search) for a graph with V vertices and E edges is:",
    "options": ["O(V)", "O(E)", "O(V+E)", "O(VE)"],
    "answer": "O(V+E)",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["BFS", "time complexity"],
    "explanation": "Each vertex and each edge is processed exactly once."
  },
  {
    "type": "mcq",
    "question": "Which of the following data structures is used in DFS (Depth-First Search)?",
    "options": ["Queue", "Stack", "Heap", "Linked List"],
    "answer": "Stack",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["DFS", "data structure"],
    "explanation": "DFS uses a stack (explicitly or via recursion) to backtrack."
  },
  {
    "type": "mcq",
    "question": "What is the minimum number of edges needed to make a disconnected graph connected?",
    "options": ["n", "Number of components - 1", "n-1", "Number of vertices"],
    "answer": "Number of components - 1",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["connectivity", "components"],
    "explanation": "You need one edge to connect each additional component."
  },
  {
    "type": "mcq",
    "question": "Which graph traversal technique is used in Dijkstra’s Algorithm?",
    "options": ["Depth-first Search", "Breadth-first Search", "Priority Queue (Greedy approach)", "Topological Sorting"],
    "answer": "Priority Queue (Greedy approach)",
    "difficulty": "hard",
    "points": 15,
    "topic": "graphs",
    "tags": ["Dijkstra", "greedy", "priority queue"],
    "explanation": "Dijkstra’s algorithm uses a min-heap (priority queue) to select the next smallest-distance vertex."
  },
  {
    "type": "mcq",
    "question": "Which one of the following graph representations is most space-efficient for sparse graphs?",
    "options": ["Adjacency Matrix", "Adjacency List", "Incidence Matrix", "Edge List"],
    "answer": "Adjacency List",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["representations", "sparse graphs"],
    "explanation": "Adjacency lists store only existing edges, using O(V+E) space."
  },
  {
    "type": "mcq",
    "question": "A simple undirected graph is a graph that has:",
    "options": ["No loops", "No multiple edges", "No direction", "All of the above"],
    "answer": "All of the above",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["simple graph", "definitions"],
    "explanation": "A simple graph has no loops, no multiple edges, and is undirected."
  },
  {
    "type": "mcq",
    "question": "Which algorithm can detect negative-weight cycles in a graph?",
    "options": ["Dijkstra’s Algorithm", "Prim’s Algorithm", "Bellman-Ford Algorithm", "Kruskal’s Algorithm"],
    "answer": "Bellman-Ford Algorithm",
    "difficulty": "hard",
    "points": 15,
    "topic": "graphs",
    "tags": ["negative cycles", "Bellman-Ford"],
    "explanation": "Bellman-Ford detects negative cycles during the relaxation process."
  },
  {
    "type": "mcq",
    "question": "In a directed graph, the maximum possible number of edges is:",
    "options": ["n", "n²", "n(n-1)/2", "2n"],
    "answer": "n²",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["directed", "max edges"],
    "explanation": "Each of n nodes can have an edge to every node (including self), giving n² edges."
  },
  {
    "type": "mcq",
    "question": "Which of the following algorithms is used to find a Minimum Spanning Tree (MST)?",
    "options": ["Dijkstra’s Algorithm", "Prim’s Algorithm", "Floyd-Warshall Algorithm", "Bellman-Ford Algorithm"],
    "answer": "Prim’s Algorithm",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["MST", "Prim"],
    "explanation": "Prim’s algorithm grows the MST by adding the cheapest edge from the tree to a new vertex."
  },
  {
    "type": "mcq",
    "question": "Which of the following is TRUE for a Directed Acyclic Graph (DAG)?",
    "options": ["It has cycles", "Topological sorting is possible", "Each node has exactly one outgoing edge", "It is always complete"],
    "answer": "Topological sorting is possible",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["DAG", "topological sort"],
    "explanation": "Only acyclic directed graphs can be topologically sorted."
  },
  {
    "type": "mcq",
    "question": "If a graph is a tree with V vertices, how many edges does it have?",
    "options": ["V", "V+1", "V-1", "V/2"],
    "answer": "V-1",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["tree", "edges"],
    "explanation": "A tree with V vertices always has V-1 edges."
  },
  {
    "type": "mcq",
    "question": "What is the space complexity of storing an adjacency matrix for a graph with V vertices?",
    "options": ["O(V)", "O(V²)", "O(V+E)", "O(E)"],
    "answer": "O(V²)",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["adjacency matrix", "space complexity"],
    "explanation": "An adjacency matrix requires storage for V×V entries."
  },
  {
    "type": "mcq",
    "question": "Which traversal technique is better for checking if a graph is bipartite?",
    "options": ["BFS", "DFS", "Dijkstra’s", "Kruskal’s"],
    "answer": "BFS",
    "difficulty": "hard",
    "points": 15,
    "topic": "graphs",
    "tags": ["bipartite", "BFS"],
    "explanation": "BFS can perform level-by-level coloring to test bipartiteness."
  },
  {
    "type": "mcq",
    "question": "In a weighted undirected graph where all edge weights are equal, which algorithm finds shortest paths from a source?",
    "options": ["BFS", "DFS", "Dijkstra’s Algorithm", "Bellman-Ford Algorithm"],
    "answer": "BFS",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["shortest path", "BFS"],
    "explanation": "With equal weights, BFS from the source yields shortest paths."
  },
  {
    "type": "mcq",
    "question": "Which statement is FALSE regarding graph representations?",
    "options": ["Adjacency list uses less space than adjacency matrix for sparse graphs", "Adjacency matrix is faster to check edge existence", "Edge list is better for dense graphs", "Adjacency list is better for iterating over neighbors"],
    "answer": "Edge list is better for dense graphs",
    "difficulty": "medium",
    "points": 10,
    "topic": "graphs",
    "tags": ["representations", "comparisons"],
    "explanation": "Edge lists become inefficient for dense graphs due to large E."
  },
  {
    "type": "mcq",
    "question": "Which problem does the Floyd–Warshall algorithm solve?",
    "options": ["Single-source shortest path", "All-pairs shortest path", "Minimum spanning tree", "Graph coloring"],
    "answer": "All-pairs shortest path",
    "difficulty": "hard",
    "points": 15,
    "topic": "graphs",
    "tags": ["Floyd–Warshall", "shortest paths"],
    "explanation": "Floyd–Warshall computes shortest distances between all pairs of vertices."
  },
  {
    "type": "mcq",
    "question": "Which of the following is a property of a complete graph with n vertices?",
    "options": ["All vertices are connected to exactly two vertices", "Number of edges = n(n-1)/2", "It has no cycles", "It is a tree"],
    "answer": "Number of edges = n(n-1)/2",
    "difficulty": "easy",
    "points": 5,
    "topic": "graphs",
    "tags": ["complete graph", "properties"],
    "explanation": "In a complete graph every pair of distinct vertices is connected by an edge."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of Kruskal’s algorithm (using union-find with path compression)?",
    "options": ["O(E log E)", "O(V²)", "O(V log V)", "O(E+V)"],
    "answer": "O(E log E)",
    "difficulty": "hard",
    "points": 15,
    "topic": "graphs",
    "tags": ["Kruskal", "MST", "time complexity"],
    "explanation": "Sorting edges dominates, giving O(E log E)."
  },
  {
    "type": "mcq",
    "question": "A binary tree is a tree in which:",
    "options": ["Every node has at most two children", "Every node has exactly two children", "Every node has at least two children", "It is always height-balanced"],
    "answer": "Every node has at most two children",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["binary tree", "definition"],
    "explanation": "A binary tree node can have 0, 1, or 2 children, but not more."
  },
  {
    "type": "mcq",
    "question": "The number of edges in a tree with n vertices is:",
    "options": ["n", "n-1", "n+1", "2n"],
    "answer": "n-1",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["tree", "edges"],
    "explanation": "Every tree with n vertices has exactly n-1 edges."
  },
  {
    "type": "mcq",
    "question": "Which traversal is used to get the prefix expression of an expression tree?",
    "options": ["Inorder", "Preorder", "Postorder", "Level-order"],
    "answer": "Preorder",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["expression tree", "traversal"],
    "explanation": "Preorder (root → left → right) yields the prefix (Polish) notation."
  },
  {
    "type": "mcq",
    "question": "What is the maximum number of nodes in a binary tree of height h?",
    "options": ["2^h - 1", "2^(h-1)", "2^h", "h^2"],
    "answer": "2^h - 1",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["binary tree", "height"],
    "explanation": "A full binary tree of height h has 2^h - 1 nodes."
  },
  {
    "type": "mcq",
    "question": "Which of the following trees is always height-balanced?",
    "options": ["Binary Search Tree", "AVL Tree", "Heap", "B-Tree"],
    "answer": "AVL Tree",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["AVL", "balanced tree"],
    "explanation": "AVL trees enforce a balance factor of -1, 0, or +1 at every node."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of searching an element in a balanced Binary Search Tree?",
    "options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
    "answer": "O(log n)",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["BST", "time complexity"],
    "explanation": "In a balanced BST, height ~ log n, so search takes O(log n)."
  },
  {
    "type": "mcq",
    "question": "In an inorder traversal of a Binary Search Tree:",
    "options": ["Nodes are visited in ascending order", "Nodes are visited in descending order", "Random order", "Cannot predict"],
    "answer": "Nodes are visited in ascending order",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["BST", "inorder"],
    "explanation": "Inorder traversal of a BST yields sorted (ascending) data."
  },
  {
    "type": "mcq",
    "question": "Which property is NOT TRUE for a max-heap?",
    "options": ["It is a complete binary tree", "Every parent ≥ children", "Left child ≥ right child", "Height = O(log n)"],
    "answer": "Left child ≥ right child",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["heap", "properties"],
    "explanation": "Heaps only enforce parent ≥ children, not any order between siblings."
  },
  {
    "type": "mcq",
    "question": "A full binary tree with 7 internal nodes has how many leaves?",
    "options": ["6", "7", "8", "9"],
    "answer": "8",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["full binary tree", "leaves"],
    "explanation": "In a full binary tree, leaves = internal nodes + 1, so 7 + 1 = 8."
  },
  {
    "type": "mcq",
    "question": "In a complete binary tree of n nodes, the height is approximately:",
    "options": ["log n", "√n", "n", "n/2"],
    "answer": "log n",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["complete binary tree", "height"],
    "explanation": "Complete binary trees have height O(log n)."
  },
  {
    "type": "mcq",
    "question": "Which traversal is used to safely delete a binary tree?",
    "options": ["Preorder", "Postorder", "Inorder", "Level-order"],
    "answer": "Postorder",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["deletion", "traversal"],
    "explanation": "Postorder deletes children before the parent node."
  },
  {
    "type": "mcq",
    "question": "The minimum number of nodes in an AVL tree of height h is approximately:",
    "options": ["2^h - 1", "2^h", "Fib(h+2) - 1", "h"],
    "answer": "Fib(h+2) - 1",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["AVL", "Fibonacci"],
    "explanation": "AVL minimum nodes follow the Fibonacci recurrence."
  },
  {
    "type": "mcq",
    "question": "Which tree structure is optimized for reading and writing large blocks of data?",
    "options": ["AVL Tree", "B-Tree", "Binary Search Tree", "Heap"],
    "answer": "B-Tree",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["B-Tree", "I/O"],
    "explanation": "B-Trees minimize disk I/O by having high branching factors."
  },
  {
    "type": "mcq",
    "question": "Which data structure is commonly used to implement a priority queue?",
    "options": ["AVL Tree", "Binary Search Tree", "Heap", "Stack"],
    "answer": "Heap",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["priority queue", "heap"],
    "explanation": "Heaps allow efficient insert and extract-max/min operations."
  },
  {
    "type": "mcq",
    "question": "Threaded binary trees use what to speed up traversal?",
    "options": ["Extra child pointers", "Array indices", "NULL pointers as threads", "Stack"],
    "answer": "NULL pointers as threads",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["threaded tree", "traversal"],
    "explanation": "Null child pointers are repurposed to point to inorder predecessor/successor."
  },
  {
    "type": "mcq",
    "question": "In a full binary tree, the number of leaf nodes is always:",
    "options": ["Internal nodes + 1", "Equal to internal nodes", "Twice the height", "Unrelated"],
    "answer": "Internal nodes + 1",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["full binary tree", "leaves"],
    "explanation": "A full binary tree with i internal nodes has i+1 leaves."
  },
  {
    "type": "mcq",
    "question": "Which of the following is FALSE for Red-Black Trees?",
    "options": ["Every path from root to leaf has same number of black nodes", "No two consecutive red nodes", "It is self-balancing", "Every node must be red"],
    "answer": "Every node must be red",
    "difficulty": "medium",
    "points": 10,
    "topic": "trees",
    "tags": ["red-black", "properties"],
    "explanation": "Red-Black Trees have both red and black nodes per the color rules."
  },
  {
    "type": "mcq",
    "question": "In an n-ary tree, a node can have at most:",
    "options": ["1 child", "n children", "2 children", "√n children"],
    "answer": "n children",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["n-ary tree", "branching factor"],
    "explanation": "By definition, each node can have up to n children."
  },
  {
    "type": "mcq",
    "question": "Which traversal visits the root first, then left subtree, then right subtree?",
    "options": ["Preorder", "Inorder", "Postorder", "Level-order"],
    "answer": "Preorder",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["traversal", "preorder"],
    "explanation": "Preorder traversal order is root → left → right."
  },
  {
    "type": "mcq",
    "question": "How many distinct binary trees can be formed with 3 nodes?",
    "options": ["3", "5", "8", "15"],
    "answer": "5",
    "difficulty": "hard",
    "points": 15,
    "topic": "trees",
    "tags": ["Catalan", "count"],
    "explanation": "The number of distinct binary trees with 3 nodes is the 3rd Catalan number, 5."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a type of binary tree?",
    "options": ["Full Binary Tree", "Complete Binary Tree", "Perfect Binary Tree", "Circular Binary Tree"],
    "answer": "Circular Binary Tree",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["binary tree", "types"],
    "explanation": "Circular binary tree is not a standard term in data structures."
  },
  {
    "type": "mcq",
    "question": "In a binary tree, the maximum number of nodes at level l is:",
    "options": ["l", "2^l", "2^(l-1)", "l^2"],
    "answer": "2^l",
    "difficulty": "easy",
    "points": 5,
    "topic": "trees",
    "tags": ["binary tree", "levels"],
    "explanation": "At level l, the maximum number of nodes is 2^l."
  },
  {
    "type": "mcq",
    "question": "Stack is based on which principle?",
    "options": ["FIFO", "LIFO", "FILO", "LOFI"],
    "answer": "LIFO",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["LIFO", "stack"],
    "explanation": "Stack is Last-In-First-Out — the last inserted is removed first."
  },
  {
    "type": "mcq",
    "question": "Which operation is performed when an item is inserted into a stack?",
    "options": ["Insert", "Append", "Push", "Pop"],
    "answer": "Push",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["push", "stack"],
    "explanation": "Inserting into a stack is called a push operation."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not an application of stack?",
    "options": ["Function call management", "Undo mechanisms", "Expression evaluation", "Shortest path finding"],
    "answer": "Shortest path finding",
    "difficulty": "medium",
    "points": 5,
    "topic": "stack",
    "tags": ["applications", "stack"],
    "explanation": "Shortest path typically uses BFS/Dijkstra, not stack."
  },
  {
    "type": "mcq",
    "question": "If a stack has n elements, how many elements will be popped to empty it completely?",
    "options": ["n", "n-1", "n+1", "2n"],
    "answer": "n",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["pop", "stack"],
    "explanation": "One pop per element to empty the stack."
  },
  {
    "type": "mcq",
    "question": "Which data structure is typically used for evaluating a postfix expression?",
    "options": ["Queue", "Stack", "Array", "Heap"],
    "answer": "Stack",
    "difficulty": "medium",
    "points": 5,
    "topic": "stack",
    "tags": ["postfix", "evaluation", "stack"],
    "explanation": "Postfix expressions are evaluated using stack by pushing operands and applying operators."
  },
  {
    "type": "mcq",
    "question": "In a stack, which element can be accessed directly?",
    "options": ["Bottom", "Middle", "Top", "Any"],
    "answer": "Top",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["access", "stack"],
    "explanation": "Only the top element is directly accessible in a stack."
  },
  {
    "type": "mcq",
    "question": "Which of the following will cause stack overflow?",
    "options": ["Using too much memory in heap", "Recursion depth too large", "Infinite loop", "Deleting elements from an empty stack"],
    "answer": "Recursion depth too large",
    "difficulty": "hard",
    "points": 5,
    "topic": "stack",
    "tags": ["overflow", "recursion", "stack"],
    "explanation": "Deep recursion without base case causes stack overflow."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of the push operation in a stack implemented by a linked list?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(1)",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["push", "linked list", "complexity"],
    "explanation": "Insert at head in linked list (used in stacks) is constant time."
  },
  {
    "type": "mcq",
    "question": "Which of the following operations cannot be efficiently performed by a stack?",
    "options": ["Insertion", "Deletion", "Random access", "Peeking at top element"],
    "answer": "Random access",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["random access", "stack"],
    "explanation": "Stack does not support random access like an array."
  },
  {
    "type": "mcq",
    "question": "Which standard library provides stack implementation in C++?",
    "options": ["iostream", "algorithm", "stack", "queue"],
    "answer": "stack",
    "difficulty": "medium",
    "points": 5,
    "topic": "stack",
    "tags": ["C++", "stack", "library"],
    "explanation": "C++ STL provides a stack container adapter."
  },
  {
    "type": "mcq",
    "question": "In what order are recursive function calls stored in memory?",
    "options": ["FIFO", "Random", "LIFO", "By priority"],
    "answer": "LIFO",
    "difficulty": "medium",
    "points": 5,
    "topic": "stack",
    "tags": ["recursion", "LIFO", "memory"],
    "explanation": "Each recursive call is pushed onto the call stack."
  },
  {
    "type": "mcq",
    "question": "When an element is deleted from a stack, it is always:",
    "options": ["Bottom element", "Middle element", "Top element", "Random element"],
    "answer": "Top element",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["pop", "stack"],
    "explanation": "Only the topmost element can be popped."
  },
  {
    "type": "mcq",
    "question": "Which of the following algorithms uses stack?",
    "options": ["Breadth-first Search", "Depth-first Search", "Dijkstra’s Algorithm", "Floyd-Warshall Algorithm"],
    "answer": "Depth-first Search",
    "difficulty": "medium",
    "points": 5,
    "topic": "stack",
    "tags": ["DFS", "stack"],
    "explanation": "DFS uses stack (either explicitly or via recursion)."
  },
  {
    "type": "mcq",
    "question": "If 5 elements are pushed into an empty stack and 3 elements are popped, how many elements are left?",
    "options": ["2", "3", "4", "5"],
    "answer": "2",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["stack", "push", "pop"],
    "explanation": "5 pushed - 3 popped = 2 elements remaining."
  },
  {
    "type": "mcq",
    "question": "Stack overflow occurs when:",
    "options": ["Stack is full and further push is attempted", "Stack is empty and pop is attempted", "Queue is full", "Array goes out of bounds"],
    "answer": "Stack is full and further push is attempted",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["overflow", "stack"],
    "explanation": "Push on full stack causes overflow."
  },
  {
    "type": "mcq",
    "question": "Which operation checks the value at the top of the stack without removing it?",
    "options": ["Pop", "Peek", "Push", "Swap"],
    "answer": "Peek",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["peek", "stack"],
    "explanation": "Peek reads the top without modifying stack contents."
  },
  {
    "type": "mcq",
    "question": "What is the minimum number of stacks needed to implement a queue?",
    "options": ["1", "2", "3", "4"],
    "answer": "2",
    "difficulty": "hard",
    "points": 5,
    "topic": "stack",
    "tags": ["queue", "stack"],
    "explanation": "Two stacks can implement a queue using two-phase method."
  },
  {
    "type": "mcq",
    "question": "Which of the following postfix expressions is invalid?",
    "options": ["23+5*", "23+5", "234+", "345+"],
    "answer": "23+5",
    "difficulty": "hard",
    "points": 5,
    "topic": "stack",
    "tags": ["postfix", "expression"],
    "explanation": "In postfix, an operator must come after two operands — no operator after 5 here."
  },
  {
    "type": "mcq",
    "question": "The minimum number of moves required to solve a Tower of Hanoi problem with n disks is:",
    "options": ["2ⁿ", "2ⁿ - 1", "n²", "n log n"],
    "answer": "2ⁿ - 1",
    "difficulty": "medium",
    "points": 5,
    "topic": "stack",
    "tags": ["Tower of Hanoi", "moves", "stack"],
    "explanation": "Classic Tower of Hanoi moves = 2ⁿ - 1."
  },
  {
    "type": "mcq",
    "question": "If a stack is implemented using an array of size 5, what is the maximum number of elements it can store?",
    "options": ["4", "5", "6", "2"],
    "answer": "5",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["array", "stack"],
    "explanation": "Size 5 array means 5 elements maximum (indexes 0 to 4)."
  },
  {
    "type": "mcq",
    "question": "Queue is based on which principle?",
    "options": ["LIFO", "FIFO", "FILO", "LOFI"],
    "answer": "FIFO",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["FIFO", "Queue Principle"],
    "explanation": "Queue is First-In-First-Out — first element inserted is the first removed."
  },
  {
    "type": "mcq",
    "question": "In a queue, where is an element inserted?",
    "options": ["At the front", "At the rear", "In the middle", "Anywhere"],
    "answer": "At the rear",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Insertion", "Queue"],
    "explanation": "Insertions happen at the rear end in a queue."
  },
  {
    "type": "mcq",
    "question": "Which of these operations is not applicable on a queue?",
    "options": ["Enqueue", "Dequeue", "Peek", "Push"],
    "answer": "Push",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Operations", "Queue"],
    "explanation": "Push is related to stacks, not queues."
  },
  {
    "type": "mcq",
    "question": "What happens when you dequeue from an empty queue?",
    "options": ["Underflow", "Overflow", "Deadlock", "Segmentation fault"],
    "answer": "Underflow",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Underflow", "Queue"],
    "explanation": "Deleting from empty queue causes underflow error."
  },
  {
    "type": "mcq",
    "question": "Which data structure is best for implementing a circular queue?",
    "options": ["Stack", "Linked list", "Array", "Tree"],
    "answer": "Array",
    "difficulty": "medium",
    "points": 5,
    "topic": "Queue",
    "tags": ["Circular Queue", "Implementation"],
    "explanation": "Circular queues are efficiently implemented using arrays with wrap-around logic."
  },
  {
    "type": "mcq",
    "question": "In a circular queue of size n, the condition for a queue to be full is:",
    "options": ["rear = front", "(rear + 1) % n == front", "rear == n", "front == rear + 1"],
    "answer": "(rear + 1) % n == front",
    "difficulty": "hard",
    "points": 5,
    "topic": "Queue",
    "tags": ["Circular Queue", "Full Condition"],
    "explanation": "In circular queues, next position after rear being front means full."
  },
  {
    "type": "mcq",
    "question": "Which of the following is not a type of queue?",
    "options": ["Priority Queue", "Circular Queue", "Deque", "Binary Queue"],
    "answer": "Binary Queue",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Types", "Queue"],
    "explanation": "No standard data structure called Binary Queue."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of enqueuing an element into a queue implemented by linked list?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(1)",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Time Complexity", "Enqueue"],
    "explanation": "Inserting at the tail of a linked list queue is O(1)."
  },
  {
    "type": "mcq",
    "question": "Which of the following uses a queue internally?",
    "options": ["Depth First Search", "Breadth First Search", "Inorder Traversal", "Postorder Traversal"],
    "answer": "Breadth First Search",
    "difficulty": "medium",
    "points": 5,
    "topic": "Queue",
    "tags": ["BFS", "Queue"],
    "explanation": "BFS uses a queue to process nodes level by level."
  },
  {
    "type": "mcq",
    "question": "If 5 elements are enqueued and 2 are dequeued, how many elements are in the queue?",
    "options": ["2", "3", "5", "7"],
    "answer": "3",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Queue Operations", "Enqueue Dequeue"],
    "explanation": "5 - 2 = 3 elements remain."
  },
  {
    "type": "mcq",
    "question": "In a double-ended queue (deque), insertion and deletion:",
    "options": ["Can happen only at rear", "Can happen only at front", "Can happen at both ends", "Cannot happen at either end"],
    "answer": "Can happen at both ends",
    "difficulty": "medium",
    "points": 5,
    "topic": "Queue",
    "tags": ["Deque", "Operations"],
    "explanation": "Deque allows insertion and deletion at both ends."
  },
  {
    "type": "mcq",
    "question": "Which of the following is true for priority queues?",
    "options": ["Insertion is based on arrival time", "Deletion happens by priority", "Deletion happens by arrival time", "Insertion is by priority but deletion is random"],
    "answer": "Deletion happens by priority",
    "difficulty": "medium",
    "points": 5,
    "topic": "Queue",
    "tags": ["Priority Queue", "Operations"],
    "explanation": "Priority queue dequeues element with highest/lowest priority."
  },
  {
    "type": "mcq",
    "question": "The maximum number of elements that can be stored in a queue implemented using an array of size 5 (without circularity) is:",
    "options": ["4", "5", "6", "Infinite"],
    "answer": "5",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Queue Capacity", "Array-based Queue"],
    "explanation": "Array of size 5 holds 5 elements without circular queue."
  },
  {
    "type": "mcq",
    "question": "Which among the following applications does NOT use queue?",
    "options": ["CPU Scheduling", "Disk Scheduling", "Call Center Systems", "Recursive Function Execution"],
    "answer": "Recursive Function Execution",
    "difficulty": "medium",
    "points": 5,
    "topic": "Queue",
    "tags": ["Queue Applications", "Recursion"],
    "explanation": "Recursion uses stack, not queue."
  },
  {
    "type": "mcq",
    "question": "In a priority queue, which element is served first?",
    "options": ["Element with highest arrival time", "Element with highest priority", "Element with lowest priority", "Random element"],
    "answer": "Element with highest priority",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Priority Queue", "Operations"],
    "explanation": "Priority queue serves the highest priority first (can be min or max priority depending on convention)."
  },
  {
    "type": "mcq",
    "question": "Which operation takes constant time (O(1)) in an array-based queue?",
    "options": ["Enqueue", "Dequeue", "Both Enqueue and Dequeue", "Neither"],
    "answer": "Both Enqueue and Dequeue",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Time Complexity", "Array-based Queue"],
    "explanation": "In array-based simple queue (with front and rear pointers), both are O(1)."
  },
  {
    "type": "mcq",
    "question": "Which is false about a circular queue?",
    "options": ["It saves memory compared to a linear queue", "Front can be greater than rear", "Rear always moves forward", "Queue can never be completely full"],
    "answer": "Queue can never be completely full",
    "difficulty": "hard",
    "points": 5,
    "topic": "Queue",
    "tags": ["Circular Queue", "Properties"],
    "explanation": "Circular queue can become completely full; special condition used to detect it."
  },
  {
    "type": "mcq",
    "question": "If initially front = rear = -1 and we enqueue an element in a queue, what will be the value of front?",
    "options": ["0", "1", "-1", "2"],
    "answer": "0",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Queue Initialization", "Enqueue"],
    "explanation": "After first enqueue, front and rear both move to 0."
  },
  {
    "type": "mcq",
    "question": "Which of the following is an example of a linear data structure?",
    "options": ["Graph", "Tree", "Queue", "Heap"],
    "answer": "Queue",
    "difficulty": "easy",
    "points": 5,
    "topic": "Queue",
    "tags": ["Linear Data Structure", "Queue"],
    "explanation": "Queue is a linear data structure (elements ordered linearly)."
  },
  {
    "type": "mcq",
    "question": "A circular queue is best when:",
    "options": ["Number of elements keeps increasing", "Memory is limited and needs efficient reuse", "Priority order is important", "Elements are inserted at multiple places"],
    "answer": "Memory is limited and needs efficient reuse",
    "difficulty": "medium",
    "points": 5,
    "topic": "Queue",
    "tags": ["Circular Queue", "Memory Efficiency"],
    "explanation": "Circular queues reuse freed up spaces effectively."
  },
  {
    "type": "mcq",
    "question": "Heap is a specialized _______ based data structure.",
    "options": ["Linear", "Graph", "Tree", "Hash"],
    "answer": "Tree",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["definition", "tree"],
    "explanation": "Heap is a complete binary tree satisfying heap properties."
  },
  {
    "type": "mcq",
    "question": "In a min-heap, the smallest element is at:",
    "options": ["Root", "Leftmost leaf", "Rightmost leaf", "Random location"],
    "answer": "Root",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["min-heap", "property"],
    "explanation": "In a min-heap, the root contains the minimum value."
  },
  {
    "type": "mcq",
    "question": "Which operation is the most expensive in a heap?",
    "options": ["Insertion", "Deletion", "Find minimum", "Find maximum"],
    "answer": "Deletion",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["operations", "complexity"],
    "explanation": "Deletion involves removing the root and heapifying, which takes O(log n)."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of inserting an element into a heap?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "answer": "O(log n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["insertion", "complexity"],
    "explanation": "Insertion requires a \"bubble-up\" (heapify-up) which takes O(log n)."
  },
  {
    "type": "mcq",
    "question": "A heap is:",
    "options": ["A sorted tree", "A balanced binary tree", "A complete binary tree", "A binary search tree"],
    "answer": "A complete binary tree",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["definition", "structure"],
    "explanation": "A heap is always a complete binary tree (filled level by level)."
  },
  {
    "type": "mcq",
    "question": "What is the maximum number of nodes at height h in a heap?",
    "options": ["2^h", "2^(h-1)", "2^(h+1)", "2h"],
    "answer": "2^h",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["structure", "levels"],
    "explanation": "Level h can have at most 2^h nodes in a binary heap."
  },
  {
    "type": "mcq",
    "question": "Which of the following applications uses a heap?",
    "options": ["Hashing", "Graph traversal", "Priority scheduling", "Stack memory management"],
    "answer": "Priority scheduling",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["applications", "priority queue"],
    "explanation": "Heaps are used in priority queues for scheduling tasks."
  },
  {
    "type": "mcq",
    "question": "Which type of heap is used for implementing a priority queue?",
    "options": ["Max-Heap only", "Min-Heap only", "Both Max-Heap and Min-Heap", "Neither"],
    "answer": "Both Max-Heap and Min-Heap",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["priority queue", "heap types"],
    "explanation": "Depending on priority definition, both max-heap and min-heap can be used."
  },
  {
    "type": "mcq",
    "question": "Which algorithm builds a heap from an unordered array in O(n) time?",
    "options": ["Heapify", "Bubble Sort", "Selection Sort", "Quick Sort"],
    "answer": "Heapify",
    "difficulty": "hard",
    "points": 15,
    "topic": "heaps",
    "tags": ["heap construction", "complexity"],
    "explanation": "The build-heap (heapify) algorithm constructs a heap in linear time."
  },
  {
    "type": "mcq",
    "question": "In a max-heap, the parent node is _______ than its children.",
    "options": ["Smaller", "Greater", "Equal", "Random"],
    "answer": "Greater",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["max-heap", "property"],
    "explanation": "Max-heap requires parent ≥ children."
  },
  {
    "type": "mcq",
    "question": "What is the minimum number of nodes in a heap of height h?",
    "options": ["2^h", "2^h + 1", "2^(h-1) + 1", "2^h - 1"],
    "answer": "2^h",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["structure", "min nodes"],
    "explanation": "A complete tree of height h has at least 2^h nodes."
  },
  {
    "type": "mcq",
    "question": "After inserting an element into a max-heap, you need to:",
    "options": ["Heapify-up", "Heapify-down", "Sort the array", "Build a new heap"],
    "answer": "Heapify-up",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["heapify", "insertion"],
    "explanation": "The inserted element moves up (heapify-up) if greater than its parent."
  },
  {
    "type": "mcq",
    "question": "After deleting the root from a heap, you must:",
    "options": ["Heapify-up", "Heapify-down", "Build a tree", "Delete entire heap"],
    "answer": "Heapify-down",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["heapify", "deletion"],
    "explanation": "Move last element to root and heapify-down to restore heap property."
  },
  {
    "type": "mcq",
    "question": "Heap sort has time complexity:",
    "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
    "answer": "O(n log n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["heap sort", "complexity"],
    "explanation": "Each of n extractions and heapify operations takes O(log n), totaling O(n log n)."
  },
  {
    "type": "mcq",
    "question": "Which of the following arrays represents a max-heap?",
    "options": ["[1, 3, 5, 7, 9, 2]", "[9, 7, 6, 5, 3, 2]", "[5, 4, 3, 2, 1, 6]", "[10, 20, 30, 40, 50]"],
    "answer": "[9, 7, 6, 5, 3, 2]",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["array representation", "max-heap"],
    "explanation": "Each parent element in array b is ≥ its children."
  },
  {
    "type": "mcq",
    "question": "The array index of the left child of node at index i in a heap is:",
    "options": ["2i", "2i + 1", "i + 1", "i/2"],
    "answer": "2i",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["indexing", "heap"],
    "explanation": "Assuming 1-based indexing, left child index = 2 × i."
  },
  {
    "type": "mcq",
    "question": "Heap is efficient mainly for:",
    "options": ["Searching", "Inserting and Deleting minimum/maximum", "Random access", "Sorting in O(n^2)"],
    "answer": "Inserting and Deleting minimum/maximum",
    "difficulty": "easy",
    "points": 5,
    "topic": "heaps",
    "tags": ["efficiency", "operations"],
    "explanation": "Heaps support fast insertion and removal of the max or min element."
  },
  {
    "type": "mcq",
    "question": "In a min-heap with n elements, approximately how many leaf nodes are there?",
    "options": ["n", "n/2", "log n", "√n"],
    "answer": "n/2",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["structure", "leaves"],
    "explanation": "In a complete binary tree, about half of the nodes are leaves."
  },
  {
    "type": "mcq",
    "question": "The best data structure to find the k largest elements efficiently is:",
    "options": ["BST", "Heap", "Hash Table", "Linked List"],
    "answer": "Heap",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["applications", "top-k"],
    "explanation": "A heap of size k can maintain the k largest elements in O(n log k)."
  },
  {
    "type": "mcq",
    "question": "If a heap has 15 nodes, its height will be:",
    "options": ["3", "4", "5", "15"],
    "answer": "4",
    "difficulty": "medium",
    "points": 10,
    "topic": "heaps",
    "tags": ["height", "logarithm"],
    "explanation": "Height = ⌊log₂(15)⌋ + 1 ≈ 4."
  },
  {
    "type": "mcq",
    "question": "Dynamic Programming is mainly used for solving problems with:",
    "options": ["Recursion", "Greedy approach", "Overlapping subproblems", "Divide and conquer only"],
    "answer": "Overlapping subproblems",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["overlapping subproblems", "definition"],
    "explanation": "DP is ideal when subproblems repeat and overlap."
  },
  {
    "type": "mcq",
    "question": "Which method is used in DP to solve subproblems first and store results?",
    "options": ["Greedy", "Memoization", "Divide and Conquer", "Branch and Bound"],
    "answer": "Memoization",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["memoization", "technique"],
    "explanation": "Memoization stores previously computed results for reuse."
  },
  {
    "type": "mcq",
    "question": "What is the time complexity of solving Fibonacci numbers using simple recursion?",
    "options": ["O(n)", "O(log n)", "O(2^n)", "O(n²)"],
    "answer": "O(2^n)",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["Fibonacci", "recursion"],
    "explanation": "Each call branches twice, leading to exponential growth."
  },
  {
    "type": "mcq",
    "question": "Which is more efficient for large inputs: memoization or tabulation?",
    "options": ["Memoization", "Tabulation", "Both are equal", "Neither"],
    "answer": "Tabulation",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["tabulation", "bottom-up"],
    "explanation": "Tabulation builds from bottom up, avoiding recursion overhead."
  },
  {
    "type": "mcq",
    "question": "The Longest Common Subsequence (LCS) problem is an example of:",
    "options": ["Greedy", "DP", "Backtracking", "Stack"],
    "answer": "DP",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["LCS", "example"],
    "explanation": "LCS has overlapping subproblems and optimal substructure."
  },
  {
    "type": "mcq",
    "question": "In DP, the property \"optimal solution contains optimal subsolutions\" is called:",
    "options": ["Optimal Substructure", "Greedy Choice", "Bottom-up approach", "Recursive Division"],
    "answer": "Optimal Substructure",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["optimal substructure", "definition"],
    "explanation": "DP problems require optimal substructure to hold."
  },
  {
    "type": "mcq",
    "question": "Which problem cannot be solved efficiently by DP?",
    "options": ["Matrix Chain Multiplication", "Subset Sum Problem", "Traveling Salesman Problem (exact solution)", "Finding maximum in an array"],
    "answer": "Finding maximum in an array",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["limitations", "subset"],
    "explanation": "Finding a maximum is O(n) without subproblem repetition."
  },
  {
    "type": "mcq",
    "question": "The space complexity of standard DP for Fibonacci numbers using tabulation is:",
    "options": ["O(1)", "O(n)", "O(log n)", "O(2^n)"],
    "answer": "O(n)",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["space complexity", "Fibonacci"],
    "explanation": "We store results for each Fibonacci number up to n."
  },
  {
    "type": "mcq",
    "question": "Which technique can reduce space in some DP problems?",
    "options": ["Using a stack", "Sliding Window or Rolling Array", "Hashing", "Sorting"],
    "answer": "Sliding Window or Rolling Array",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["space optimization", "rolling array"],
    "explanation": "Some problems need only the last few values, reducing storage."
  },
  {
    "type": "mcq",
    "question": "In 0/1 Knapsack DP, the decision at each item is:",
    "options": ["Include or exclude", "Multiply or divide", "Pick minimum", "Pick maximum immediately"],
    "answer": "Include or exclude",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["knapsack", "decision"],
    "explanation": "At each item you choose to take it or leave it."
  },
  {
    "type": "mcq",
    "question": "Which of the following is NOT an example of overlapping subproblems?",
    "options": ["Fibonacci sequence", "Merge Sort", "Matrix Chain Multiplication", "0/1 Knapsack"],
    "answer": "Merge Sort",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["merge sort", "divide and conquer"],
    "explanation": "Merge Sort uses divide-and-conquer without overlapping."
  },
  {
    "type": "mcq",
    "question": "Which structure is most often used to store DP subproblems?",
    "options": ["Stack", "Queue", "Table (Array / Matrix)", "Tree"],
    "answer": "Table (Array / Matrix)",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["storage", "table"],
    "explanation": "Tables (arrays/matrices) store intermediate DP results."
  },
  {
    "type": "mcq",
    "question": "The shortest path in a weighted directed graph with non-negative weights can be solved efficiently using:",
    "options": ["Dijkstra’s Algorithm", "Bellman-Ford Algorithm", "DP based Floyd-Warshall", "Kruskal’s Algorithm"],
    "answer": "Dijkstra’s Algorithm",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["shortest path", "Dijkstra"],
    "explanation": "Dijkstra’s algorithm is efficient for non-negative weights."
  },
  {
    "type": "mcq",
    "question": "Which DP approach solves subproblems only when needed?",
    "options": ["Tabulation", "Memoization", "Greedy", "Graph traversal"],
    "answer": "Memoization",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["memoization", "top-down"],
    "explanation": "Memoization is top-down, solving only necessary subproblems."
  },
  {
    "type": "mcq",
    "question": "Tabulation typically follows which order?",
    "options": ["Top-down", "Bottom-up", "Random", "Depth-first"],
    "answer": "Bottom-up",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["tabulation", "order"],
    "explanation": "Tabulation builds solutions from the simplest up."
  },
  {
    "type": "mcq",
    "question": "The Bellman-Ford algorithm for shortest path is based on:",
    "options": ["Greedy", "Divide and Conquer", "Dynamic Programming", "Backtracking"],
    "answer": "Dynamic Programming",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["Bellman-Ford", "relaxation"],
    "explanation": "Bellman-Ford relaxes edges in multiple passes, a DP technique."
  },
  {
    "type": "mcq",
    "question": "If a problem shows overlapping subproblems but no optimal substructure, can we apply DP?",
    "options": ["Always", "Never", "Sometimes", "Only for small inputs"],
    "answer": "Never",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["optimal substructure", "requirements"],
    "explanation": "DP requires both overlapping subproblems and optimal substructure."
  },
  {
    "type": "mcq",
    "question": "Which of these sorting techniques can be thought of as an application of DP?",
    "options": ["Merge Sort", "Quick Sort", "Insertion Sort", "Radix Sort"],
    "answer": "Radix Sort",
    "difficulty": "hard",
    "points": 15,
    "topic": "dynamic programming",
    "tags": ["radix sort", "application"],
    "explanation": "Radix Sort processes digits sequentially, similar to DP stages."
  },
  {
    "type": "mcq",
    "question": "What is the best way to optimize time for recursive DP?",
    "options": ["Use arrays instead of lists", "Remove function calls", "Add memoization", "Increase recursion depth"],
    "answer": "Add memoization",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["optimization", "memoization"],
    "explanation": "Memoization caches results to avoid repeated computation."
  },
  {
    "type": "mcq",
    "question": "Dynamic programming always guarantees:",
    "options": ["Minimum memory", "Fastest execution", "Optimal solution", "Greedy choices"],
    "answer": "Optimal solution",
    "difficulty": "easy",
    "points": 5,
    "topic": "dynamic programming",
    "tags": ["guarantee", "optimality"],
    "explanation": "DP ensures global optimality via optimal substructure."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: int arr[5] = {1, 2, 3, 4, 5}; for(int i = 0; i <= 5; i++) { cout << arr[i] << ' '; }",
    "code": "int arr[5] = {1, 2, 3, 4, 5}; for(int i = 0; i <= 5; i++) { cout << arr[i] << ' '; }",
    "answer": "Accessing arr[5] → Array Index Out of Bounds.",
    "difficulty": "medium",
    "points": 10,
    "topic": "array",
    "tags": ["index_out_of_bounds"],
    "explanation": "The loop condition should be i < 5, not i <= 5."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: arr = [1, 2, 3] print(arr[3])",
    "code": "arr = [1, 2, 3] print(arr[3])",
    "answer": "IndexError, valid indices are 0, 1, 2.",
    "difficulty": "easy",
    "points": 5,
    "topic": "array",
    "tags": ["index_error"],
    "explanation": "Index 3 is out of bounds for the array with valid indices 0, 1, 2."
  },
  {
    "type": "debugging",
    "question": "What's printed in this code: int arr[] = new int[5]; System.out.println(arr[0]);",
    "code": "int arr[] = new int[5]; System.out.println(arr[0]);",
    "answer": "0 — Java initializes arrays to 0 by default.",
    "difficulty": "easy",
    "points": 5,
    "topic": "array",
    "tags": ["default_value"],
    "explanation": "In Java, arrays of integers are initialized to 0 by default."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: int arr[3]; arr[0] = 1; arr[3] = 5;",
    "code": "int arr[3]; arr[0] = 1; arr[3] = 5;",
    "answer": "arr[3] is out of bounds (valid: 0-2).",
    "difficulty": "medium",
    "points": 10,
    "topic": "array",
    "tags": ["index_out_of_bounds"],
    "explanation": "Array indices range from 0 to 2 for an array of size 3."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: arr = [] arr[0] = 10",
    "code": "arr = [] arr[0] = 10",
    "answer": "IndexError — cannot assign before appending elements.",
    "difficulty": "medium",
    "points": 10,
    "topic": "array",
    "tags": ["index_error"],
    "explanation": "You need to append elements to the list before accessing them."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: Node* temp = head; while(temp != NULL) temp = temp->next; cout << temp->data;",
    "code": "Node* temp = head; while(temp != NULL) temp = temp->next; cout << temp->data;",
    "answer": "Missing braces {}, cout executes after loop ends.",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["logic_error", "infinite_loop"],
    "explanation": "The cout statement should be inside the while loop, or the loop should terminate with a valid condition."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: class Node: def __init__(self, data): self.data = data self.next = None head = None print(head.data)",
    "code": "class Node: def __init__(self, data): self.data = data self.next = None head = None print(head.data)",
    "answer": "AttributeError, head is None, no data attribute.",
    "difficulty": "easy",
    "points": 5,
    "topic": "linked list",
    "tags": ["none_type_error"],
    "explanation": "head is None, so there is no data attribute to access."
  },
  {
    "type": "debugging",
    "question": "What happens if head is null in this code: Node temp = head; while(temp.next != null) temp = temp.next; System.out.println(temp.data);",
    "code": "Node temp = head; while(temp.next != null) temp = temp.next; System.out.println(temp.data);",
    "answer": "NullPointerException on temp.next.",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["null_pointer_exception"],
    "explanation": "You need to check if head is null before accessing temp.next."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: struct Node { int data; struct Node* next; }; struct Node* head = NULL; head->data = 5;",
    "code": "struct Node { int data; struct Node* next; }; struct Node* head = NULL; head->data = 5;",
    "answer": "Segmentation fault, head is NULL, can't assign.",
    "difficulty": "medium",
    "points": 10,
    "topic": "linked list",
    "tags": ["segmentation_fault"],
    "explanation": "head is NULL, dereferencing it causes a segmentation fault."
  },
  {
    "type": "debugging",
    "question": "What's happening in this code: head = Node(1) head.next = Node(2) head.next.next = head",
    "code": "head = Node(1) head.next = Node(2) head.next.next = head",
    "answer": "Creates infinite loop in the linked list.",
    "difficulty": "hard",
    "points": 15,
    "topic": "linked list",
    "tags": ["infinite_loop"],
    "explanation": "head.next.next points to head, creating a circular reference."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: graph = {} graph[1].append(2)",
    "code": "graph = {} graph[1].append(2)",
    "answer": "KeyError — must initialize graph[1] = [] first.",
    "difficulty": "medium",
    "points": 10,
    "topic": "graph",
    "tags": ["key_error"],
    "explanation": "Before appending to graph[1], you need to initialize graph[1] as an empty list."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: vector<int> adj[5]; adj[5].push_back(1);",
    "code": "vector<int> adj[5]; adj[5].push_back(1);",
    "answer": "Array out of bounds, valid indices are 0-4.",
    "difficulty": "medium",
    "points": 10,
    "topic": "graph",
    "tags": ["array_out_of_bounds"],
    "explanation": "Index 5 is out of bounds for the array of size 5."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: if(visited[v] == false) dfs(v); visited[v] = true;",
    "code": "if(visited[v] == false) dfs(v); visited[v] = true;",
    "answer": "Marking visited after DFS leads to infinite recursion.",
    "difficulty": "hard",
    "points": 15,
    "topic": "graph",
    "tags": ["infinite_recursion"],
    "explanation": "Marking the node as visited after calling DFS causes infinite recursion."
  },
  {
    "type": "debugging",
    "question": "What's happening in this code: for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) if(graph[i][j] == 1) graph[j][i] = 1;",
    "code": "for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) if(graph[i][j] == 1) graph[j][i] = 1;",
    "answer": "Incorrect for undirected graph; already symmetric.",
    "difficulty": "medium",
    "points": 10,
    "topic": "graph",
    "tags": ["logic_error"],
    "explanation": "The graph is already symmetric for an undirected graph."
  },
  {
    "type": "debugging",
    "question": "What's missing in this DFS code: def dfs(graph, v, visited): if visited[v]: return visited[v] = True for u in graph[v]: dfs(graph, u, visited)",
    "code": "def dfs(graph, v, visited): if visited[v]: return visited[v] = True for u in graph[v]: dfs(graph, u, visited)",
    "answer": "No base case for v not existing in graph → KeyError.",
    "difficulty": "hard",
    "points": 15,
    "topic": "graph",
    "tags": ["key_error"],
    "explanation": "You need to handle the case where v doesn't exist in the graph."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: void inorder(TreeNode* root) { inorder(root->left); cout << root->data; inorder(root->right); }",
    "code": "void inorder(TreeNode* root) { inorder(root->left); cout << root->data; inorder(root->right); }",
    "answer": "No null check — causes infinite recursion.",
    "difficulty": "easy",
    "points": 5,
    "topic": "tree",
    "tags": ["null_check"],
    "explanation": "You need to check if root is NULL to avoid infinite recursion."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: def height(root): if root == None: return return max(height(root.left), height(root.right)) + 1",
    "code": "def height(root): if root == None: return return max(height(root.left), height(root.right)) + 1",
    "answer": "None returns None, not 0 → TypeError in max().",
    "difficulty": "medium",
    "points": 10,
    "topic": "tree",
    "tags": ["type_error"],
    "explanation": "The return value of None is not valid for the max function."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: TreeNode root = null; System.out.println(root.left);",
    "code": "TreeNode root = null; System.out.println(root.left);",
    "answer": "NullPointerException.",
    "difficulty": "easy",
    "points": 5,
    "topic": "tree",
    "tags": ["null_pointer_exception"],
    "explanation": "root is null, so accessing root.left causes a NullPointerException."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: struct TreeNode { int data; struct TreeNode *left, *right; }; TreeNode* root; root->data = 10;",
    "code": "struct TreeNode { int data; struct TreeNode *left, *right; }; TreeNode* root; root->data = 10;",
    "answer": "root is uninitialized (wild pointer).",
    "difficulty": "medium",
    "points": 10,
    "topic": "tree",
    "tags": ["wild_pointer"],
    "explanation": "root is uninitialized, which causes undefined behavior."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code: def insertBST(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insertBST(root.left, val) else: insertBST(root.right, val) return root",
    "code": "def insertBST(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insertBST(root.left, val) else: insertBST(root.right, val) return root",
    "answer": "No root.left or root.right assignment in else case.",
    "difficulty": "hard",
    "points": 15,
    "topic": "tree",
    "tags": ["logic_error"],
    "explanation": "The recursive calls in the else case don't update the root reference."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? stack = []\nstack.pop()",
    "code": "stack = []\nstack.pop()",
    "answer": "IndexError — popping from an empty stack.",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["python", "empty_stack", "error"],
    "explanation": "You cannot pop from an empty stack. This results in an IndexError."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? stack<int> s;\ns.push(1);\ncout << s.top();\ns.pop();\ncout << s.top();",
    "code": "stack<int> s;\ns.push(1);\ncout << s.top();\ns.pop();\ncout << s.top();",
    "answer": "Accessing top after popping → undefined behavior.",
    "difficulty": "medium",
    "points": 10,
    "topic": "stack",
    "tags": ["cpp", "undefined_behavior", "top_access"],
    "explanation": "After popping, the stack is empty, and accessing the top leads to undefined behavior."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? Stack<Integer> stack = new Stack<>();\nstack.peek();",
    "code": "Stack<Integer> stack = new Stack<>();\nstack.peek();",
    "answer": "EmptyStackException if stack is empty.",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["java", "empty_stack", "exception"],
    "explanation": "The peek method throws an EmptyStackException if the stack is empty."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? int stack[MAX];\nint top = -1;\ntop--;",
    "code": "int stack[MAX];\nint top = -1;\ntop--;",
    "answer": "Underflow — decrementing top without any elements.",
    "difficulty": "medium",
    "points": 10,
    "topic": "stack",
    "tags": ["c", "stack_underflow", "top"],
    "explanation": "You can't decrement top without any elements. This results in a stack underflow."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? def isEmpty(stack):\nreturn len(stack) == 1",
    "code": "def isEmpty(stack):\nreturn len(stack) == 1",
    "answer": "Should be len(stack) == 0, not 1.",
    "difficulty": "easy",
    "points": 5,
    "topic": "stack",
    "tags": ["python", "empty_stack", "len"],
    "explanation": "The correct condition to check if the stack is empty should be len(stack) == 0, not 1."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? queue<int> q;\nq.front();",
    "code": "queue<int> q;\nq.front();",
    "answer": "Undefined behavior — accessing front of empty queue.",
    "difficulty": "easy",
    "points": 5,
    "topic": "queue",
    "tags": ["cpp", "empty_queue", "front_access"],
    "explanation": "You cannot access the front of an empty queue. This leads to undefined behavior."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? from collections import deque\nq = deque()\nq.popleft()",
    "code": "from collections import deque\nq = deque()\nq.popleft()",
    "answer": "IndexError, cannot pop from empty deque.",
    "difficulty": "easy",
    "points": 5,
    "topic": "queue",
    "tags": ["python", "deque", "empty_queue"],
    "explanation": "You cannot pop from an empty deque. This raises an IndexError."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? Queue<Integer> q = new LinkedList<>();\nq.remove();",
    "code": "Queue<Integer> q = new LinkedList<>();\nq.remove();",
    "answer": "NoSuchElementException if queue is empty.",
    "difficulty": "medium",
    "points": 10,
    "topic": "queue",
    "tags": ["java", "empty_queue", "exception"],
    "explanation": "The remove method throws a NoSuchElementException if the queue is empty."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? int front = 0, rear = 0;\nenqueue(x);\nif(front == rear) \ndequeue();\ndequeue();",
    "code": "int front = 0, rear = 0;\nenqueue(x);\nif(front == rear) \ndequeue();\ndequeue();",
    "answer": "Dequeueing twice without check → underflow.",
    "difficulty": "medium",
    "points": 10,
    "topic": "queue",
    "tags": ["c", "queue_underflow", "dequeue"],
    "explanation": "You cannot dequeue twice without checking if the queue is empty. This results in underflow."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? q = []\nq.pop(0)\nq.pop(0)",
    "code": "q = []\nq.pop(0)\nq.pop(0)",
    "answer": "IndexError on second pop — list empty.",
    "difficulty": "easy",
    "points": 5,
    "topic": "queue",
    "tags": ["python", "list", "empty_queue"],
    "explanation": "You cannot pop from an empty list. The second pop raises an IndexError."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? priority_queue<int> pq;\npq.top();",
    "code": "priority_queue<int> pq;\npq.top();",
    "answer": "Undefined behavior — pq is empty.",
    "difficulty": "medium",
    "points": 10,
    "topic": "heap",
    "tags": ["cpp", "priority_queue", "empty_heap"],
    "explanation": "You cannot access the top of an empty priority queue. This leads to undefined behavior."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? import heapq\nh = []\nheapq.heappop(h)",
    "code": "import heapq\nh = []\nheapq.heappop(h)",
    "answer": "IndexError — popping from empty heap.",
    "difficulty": "easy",
    "points": 5,
    "topic": "heap",
    "tags": ["python", "heapq", "empty_heap"],
    "explanation": "You cannot pop from an empty heap. This raises an IndexError."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? PriorityQueue<Integer> pq = new PriorityQueue<>();\nSystem.out.println(pq.peek());",
    "code": "PriorityQueue<Integer> pq = new PriorityQueue<>();\nSystem.out.println(pq.peek());",
    "answer": "peek() on empty PriorityQueue returns null, not exception.",
    "difficulty": "easy",
    "points": 5,
    "topic": "heap",
    "tags": ["java", "priority_queue", "peek"],
    "explanation": "The peek method returns null when called on an empty priority queue, not an exception."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? int heap[MAX];\nint size = 0;\nheap[0] = 10;\nsize++;",
    "code": "int heap[MAX];\nint size = 0;\nheap[0] = 10;\nsize++;",
    "answer": "Heap indexing usually starts from 1 for clarity; confusion can arise.",
    "difficulty": "medium",
    "points": 10,
    "topic": "heap",
    "tags": ["c", "heap_indexing", "clarity"],
    "explanation": "Heap indexing typically starts from 1, and using index 0 can cause confusion."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? import heapq\nh = [10, 20, 15]\nheapq.heapify(h)\nh[0] = 50\nheapq.heappop(h)",
    "code": "import heapq\nh = [10, 20, 15]\nheapq.heapify(h)\nh[0] = 50\nheapq.heappop(h)",
    "answer": "After manually changing h[0], heap property is broken.",
    "difficulty": "hard",
    "points": 15,
    "topic": "heap",
    "tags": ["python", "heapq", "heap_property"],
    "explanation": "Manually changing the root element (h[0]) breaks the heap property, causing heap operations to fail."
  },
  {
    "type": "debugging",
    "question": "What's inefficient in this code? def fib(n):\nif n <= 1:\nreturn n\nreturn fib(n-1) + fib(n-2)",
    "code": "def fib(n):\nif n <= 1:\nreturn n\nreturn fib(n-1) + fib(n-2)",
    "answer": "No memoization → exponential time.",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["python", "memoization", "fib"],
    "explanation": "Without memoization, the function repeatedly computes the same values leading to exponential time complexity."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? dp[n] = dp[n-1] + dp[n-2];",
    "code": "dp[n] = dp[n-1] + dp[n-2];",
    "answer": "Base cases for dp[0], dp[1] might not be set.",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["cpp", "dp", "base_cases"],
    "explanation": "The base cases for dp[0] and dp[1] might not be initialized, leading to undefined behavior when they are accessed."
  },
  {
    "type": "debugging",
    "question": "What happens if n < 2 in this code? dp = [0] * n\ndp[1] = 1\nfor i in range(2, n):\ndp[i] = dp[i-1] + dp[i-2]",
    "code": "dp = [0] * n\ndp[1] = 1\nfor i in range(2, n):\ndp[i] = dp[i-1] + dp[i-2]",
    "answer": "IndexError — accessing dp[1] when n=1.",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["python", "dp", "index_error"],
    "explanation": "When n < 2, dp[1] cannot be assigned, leading to an IndexError when accessing dp[1]."
  },
  {
    "type": "debugging",
    "question": "What's wrong in this code? dp[0] = dp[1] = 1;\nfor(int i=2;i<n;i++)\ndp[i] = dp[i-1] + dp[i-2];",
    "code": "dp[0] = dp[1] = 1;\nfor(int i=2;i<n;i++)\ndp[i] = dp[i-1] + dp[i-2];",
    "answer": "If n = 1, then dp[1] assignment throws exception if array too small.",
    "difficulty": "medium",
    "points": 10,
    "topic": "dynamic programming",
    "tags": ["java", "dp", "array_size"],
    "explanation": "If n = 1, the array is too small to assign dp[1], which throws an exception."
  },
  {
    "type": "debugging",
    "question": "What's missing in this code? def knapsack(weights, values, W):\nif W == 0:\nreturn 0\nif W < 0:\nreturn 0\nmax_val = 0\nfor i in range(len(weights)):\nmax_val = max(max_val, knapsack(weights, values, W - weights[i]) + values[i])\nreturn max_val",
    "code": "def knapsack(weights, values, W):\nif W == 0:\nreturn 0\nif W < 0:\nreturn 0\nmax_val = 0\nfor i in range(len(weights)):\nmax_val = max(max_val, knapsack(weights, values, W - weights[i]) + values[i])\nreturn max_val",
    "answer": "No memoization — leads to TLE (Time Limit Exceeded).",
    "difficulty": "hard",
    "points": 15,
    "topic": "dynamic programming",
    "tags": ["python", "knapsack", "memoization"],
    "explanation": "Without memoization, the function recalculates the same subproblems repeatedly, leading to a Time Limit Exceeded error."
  },
    {
      "type": "interview",
      "question": "What is the difference between an array and a linked list?",
      "expected_answer": "An array is a fixed-size data structure that stores elements in contiguous memory locations. A linked list is a dynamic data structure that stores elements in nodes, where each node points to the next node. Arrays have constant-time access to elements, while linked lists have linear-time access.",
      "difficulty": "medium",
      "points": 10,
      "topic": "arrays",
      "tags": ["arrays", "linked list"],
      "explanation": "Arrays allow direct access via indices, whereas linked lists use nodes with pointers."
    },
    {
      "type": "interview",
      "question": "What is the time complexity of accessing an element in an array?",
      "expected_answer": "The time complexity for accessing an element in an array is O(1) since arrays allow direct access using an index.",
      "difficulty": "easy",
      "points": 5,
      "topic": "arrays",
      "tags": ["arrays", "time complexity"],
      "explanation": "Array elements are stored in contiguous memory locations, so accessing them via index takes constant time."
    },
    {
      "type": "interview",
      "question": "How do you find the middle element of an array?",
      "expected_answer": "The middle element of an array can be found by accessing the element at index n//2 where n is the length of the array.",
      "difficulty": "easy",
      "points": 5,
      "topic": "arrays",
      "tags": ["arrays", "middle element"],
      "explanation": "In an array, the middle element is the one at the index half of the array's length."
    },
    {
      "type": "interview",
      "question": "Explain how you can rotate an array.",
      "expected_answer": "Array rotation involves shifting the elements of the array by a specified number of positions. One common method is to reverse parts of the array and then reverse the entire array.",
      "difficulty": "medium",
      "points": 10,
      "topic": "arrays",
      "tags": ["arrays", "rotation"],
      "explanation": "Array rotation can be done by reversing sections of the array and then reversing the whole array to achieve the desired rotation."
    },
    {
      "type": "interview",
      "question": "How do you find the largest sum of a contiguous subarray?",
      "expected_answer": "The largest sum of a contiguous subarray can be found using Kadane’s Algorithm, which runs in O(n) time. It maintains a running sum and resets it when the sum becomes negative.",
      "difficulty": "medium",
      "points": 15,
      "topic": "arrays",
      "tags": ["arrays", "Kadane's algorithm", "subarray"],
      "explanation": "Kadane's Algorithm efficiently computes the maximum sum by maintaining a running sum that is reset when negative."
    },
    {
      "type": "interview",
      "question": "What is the difference between a singly linked list and a doubly linked list?",
      "expected_answer": "In a singly linked list, each node points to the next node, whereas in a doubly linked list, each node points to both the next and the previous nodes, allowing traversal in both directions.",
      "difficulty": "medium",
      "points": 10,
      "topic": "linked list",
      "tags": ["singly linked list", "doubly linked list"],
      "explanation": "A singly linked list allows one-way traversal, while a doubly linked list allows traversal in both directions."
    },
    {
      "type": "interview",
      "question": "How do you reverse a linked list?",
      "expected_answer": "Reversing a linked list involves reassigning the next pointers of each node so that they point to the previous node. This can be done iteratively or recursively.",
      "difficulty": "medium",
      "points": 10,
      "topic": "linked list",
      "tags": ["linked list", "reversal"],
      "explanation": "Reversing the list involves changing the direction of the pointers, either iteratively or recursively."
    },
    {
      "type": "interview",
      "question": "How do you detect a cycle in a linked list?",
      "expected_answer": "You can detect a cycle in a linked list using Floyd’s Tortoise and Hare algorithm, which uses two pointers moving at different speeds. If they meet, a cycle exists.",
      "difficulty": "medium",
      "points": 15,
      "topic": "linked list",
      "tags": ["linked list", "cycle detection"],
      "explanation": "Floyd’s Tortoise and Hare algorithm helps detect cycles by having two pointers move at different speeds. If they meet, a cycle is present."
    },
    {
      "type": "interview",
      "question": "How do you find the middle of a linked list?",
      "expected_answer": "To find the middle of a linked list, use two pointers: one moves one step at a time, while the other moves two steps at a time. When the faster pointer reaches the end, the slower pointer will be at the middle.",
      "difficulty": "easy",
      "points": 5,
      "topic": "linked list",
      "tags": ["linked list", "middle element"],
      "explanation": "By using two pointers, one moving fast and the other slow, the slow pointer will reach the middle when the fast pointer reaches the end."
    },
    {
      "type": "interview",
      "question": "How do you merge two sorted linked lists?",
      "expected_answer": "To merge two sorted linked lists, use a two-pointer technique: compare the values of the current nodes in both lists and append the smaller node to the result, moving the respective pointer ahead.",
      "difficulty": "medium",
      "points": 15,
      "topic": "linked list",
      "tags": ["linked list", "merge sorted lists"],
      "explanation": "By comparing the values of nodes in two sorted linked lists, you can merge them in order using two pointers."
    },
    {
      "type": "interview",
      "question": "What is a binary tree?",
      "expected_answer": "A binary tree is a tree data structure in which each node has at most two children, commonly referred to as the left child and the right child.",
      "difficulty": "easy",
      "points": 5,
      "topic": "trees",
      "tags": ["binary tree"],
      "explanation": "A binary tree is defined by the property that each node has at most two children, left and right."
    },
    {
      "type": "interview",
      "question": "What is the difference between a binary tree and a binary search tree?",
      "expected_answer": "In a binary tree, there is no particular order to the nodes. In a binary search tree, for any node, the left child contains smaller values, and the right child contains larger values.",
      "difficulty": "medium",
      "points": 10,
      "topic": "trees",
      "tags": ["binary tree", "binary search tree"],
      "explanation": "A binary search tree enforces an order between its nodes, whereas a binary tree does not have any such constraints."
    },
    {
      "type": "interview",
      "question": "How do you traverse a tree?",
      "expected_answer": "Trees can be traversed using three main methods: Inorder (left-root-right), Preorder (root-left-right), and Postorder (left-right-root). These can be implemented using recursion or iteration.",
      "difficulty": "medium",
      "points": 10,
      "topic": "trees",
      "tags": ["tree traversal", "inorder", "preorder", "postorder"],
      "explanation": "Tree traversal methods allow visiting each node in a specific order, either through recursion or iteration."
    },
    {
      "type": "interview",
      "question": "What is a balanced binary tree?",
      "expected_answer": "A balanced binary tree is a binary tree where the height of the left and right subtrees of any node differs by at most one. Examples include AVL trees and Red-Black trees.",
      "difficulty": "medium",
      "points": 15,
      "topic": "trees",
      "tags": ["balanced binary tree", "AVL tree", "Red-Black tree"],
      "explanation": "Balanced binary trees ensure that the height difference between the subtrees is minimal, which optimizes operations like search and insertion."
    },
    {
      "type": "interview",
      "question": "What is the height of a binary tree?",
      "expected_answer": "The height of a binary tree is the number of edges in the longest path from the root to a leaf. It is calculated by finding the maximum height of the left and right subtrees.",
      "difficulty": "easy",
      "points": 5,
      "topic": "trees",
      "tags": ["binary tree", "height"],
      "explanation": "The height of a binary tree is the length of the longest path from the root to any leaf node."
    },
    {
      "type": "interview",
      "question": "What is the difference between a graph and a tree?",
      "expected_answer": "A tree is a special type of graph where there are no cycles and there is exactly one path between any two nodes. A graph may contain cycles and may have multiple paths between nodes.",
      "difficulty": "medium",
      "points": 10,
      "topic": "graphs",
      "tags": ["graph", "tree", "cycle"],
      "explanation": "A tree is a type of graph with no cycles, while a graph can have cycles and multiple paths between nodes."
    },
    {
      "type": "interview",
      "question": "What are the types of graphs?",
      "expected_answer": "Graphs can be classified as directed or undirected, weighted or unweighted, and cyclic or acyclic. They can also be represented as adjacency matrices or adjacency lists.",
      "difficulty": "medium",
      "points": 10,
      "topic": "graphs",
      "tags": ["graph types", "directed", "undirected", "weighted", "unweighted"],
      "explanation": "Graphs can vary in terms of directionality, weight, and presence of cycles, and can be represented in different ways."
    },
    {
      "type": "interview",
      "question": "What is BFS (Breadth-First Search)?",
      "expected_answer": "BFS is a graph traversal algorithm that explores all the nodes at the present depth level before moving on to nodes at the next depth level. It uses a queue data structure and is typically used to find the shortest path in an unweighted graph.",
      "difficulty": "medium",
      "points": 15,
      "topic": "graphs",
      "tags": ["BFS", "breadth-first search", "graph traversal"],
      "explanation": "BFS explores nodes level by level using a queue and is effective for finding the shortest path in unweighted graphs."
    },
    {
      "type": "interview",
      "question": "What is DFS (Depth-First Search)?",
      "expected_answer": "DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack or recursion and is useful for topological sorting, cycle detection, etc.",
      "difficulty": "medium",
      "points": 15,
      "topic": "graphs",
      "tags": ["DFS", "depth-first search", "graph traversal"],
      "explanation": "DFS explores nodes by going deep into branches first and is useful for tasks like cycle detection and topological sorting."
    },
    {
      "type": "interview",
      "question": "How do you detect a cycle in an undirected graph?",
      "expected_answer": "To detect a cycle in an undirected graph, perform a DFS traversal and track the parent of each node. If a node is visited that is not the parent of the current node, a cycle exists.",
      "difficulty": "medium",
      "points": 15,
      "topic": "graphs",
      "tags": ["cycle detection", "DFS", "undirected graph"],
      "explanation": "Cycle detection in an undirected graph can be done during DFS traversal by checking for nodes visited that are not the parent."
    },
    {
      "type": "interview",
      "question": "What is Dijkstra's algorithm?",
      "expected_answer": "Dijkstra's algorithm is a greedy algorithm used to find the shortest path from a source node to all other nodes in a weighted graph with non-negative weights. It uses a priority queue to select the node with the smallest distance.",
      "difficulty": "hard",
      "points": 20,
      "topic": "graphs",
      "tags": ["Dijkstra's algorithm", "shortest path", "weighted graph"],
      "explanation": "Dijkstra's algorithm efficiently finds the shortest paths in a weighted graph using a priority queue."
    },
    {
      "type": "interview",
      "question": "What is a heap?",
      "expected_answer": "A heap is a complete binary tree that satisfies the heap property. In a max-heap, the value of each node is greater than or equal to the values of its children. In a min-heap, the value of each node is less than or equal to the values of its children.",
      "difficulty": "medium",
      "points": 10,
      "topic": "heaps",
      "tags": ["heap", "binary tree", "max-heap", "min-heap"],
      "explanation": "A heap is a complete binary tree that satisfies either the max-heap or min-heap property, depending on the structure."
    },
    {
      "type": "interview",
      "question": "What is the time complexity of inserting an element into a heap?",
      "expected_answer": "The time complexity of inserting an element into a heap is O(log n) because it may require reheapification of the tree.",
      "difficulty": "medium",
      "points": 10,
      "topic": "heaps",
      "tags": ["heap", "insertion", "complexity"],
      "explanation": "Insertion into a heap involves adding an element and then reheapifying, which takes O(log n) time."
    },
    {
      "type": "interview",
      "question": "What is the difference between a binary tree and a heap?",
      "expected_answer": "A binary tree does not require any specific structure other than having at most two children per node, while a heap must satisfy the heap property (max or min) and is always a complete binary tree.",
      "difficulty": "medium",
      "points": 10,
      "topic": "heaps",
      "tags": ["binary tree", "heap", "difference"],
      "explanation": "A heap is a complete binary tree that satisfies a specific ordering property (max or min), whereas a binary tree does not enforce any such structure."
    },
    {
      "type": "interview",
      "question": "How do you extract the maximum element from a max-heap?",
      "expected_answer": "To extract the maximum element, remove the root of the heap and replace it with the last element in the heap. Then, perform a heapify operation to restore the heap property.",
      "difficulty": "medium",
      "points": 15,
      "topic": "heaps",
      "tags": ["max-heap", "extraction", "heapify"],
      "explanation": "The maximum element is at the root of a max-heap. After removal, the heap is restructured to maintain the heap property using a heapify operation."
    },
    {
      "type": "interview",
      "question": "What is the use of heaps in priority queues?",
      "expected_answer": "Heaps are used in priority queues to ensure that the highest (or lowest) priority element can be efficiently accessed. The heap allows both insertion and deletion operations to be performed in O(log n) time.",
      "difficulty": "medium",
      "points": 15,
      "topic": "heaps",
      "tags": ["priority queue", "heap", "insertion", "deletion"],
      "explanation": "Heaps are an ideal structure for priority queues due to their efficient O(log n) insertion and deletion times, ensuring quick access to the highest or lowest priority element."
    },
    {
      "type": "interview",
      "question": "What is a stack?",
      "expected_answer": "A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, where the last element added to the stack is the first to be removed.",
      "difficulty": "medium",
      "points": 10,
      "topic": "stacks",
      "tags": ["stack", "LIFO"],
      "explanation": "A stack operates on the Last In, First Out (LIFO) principle, where the most recently added element is the first to be removed."
    },
    {
      "type": "interview",
      "question": "What are the primary operations of a stack?",
      "expected_answer": "The primary operations of a stack are push (add an element to the stack), pop (remove the top element), and peek (view the top element without removing it).",
      "difficulty": "medium",
      "points": 10,
      "topic": "stacks",
      "tags": ["stack", "operations", "push", "pop", "peek"],
      "explanation": "The stack supports three main operations: push to add elements, pop to remove elements, and peek to view the top element."
    },
    {
      "type": "interview",
      "question": "What is the time complexity of the pop operation in a stack?",
      "expected_answer": "The time complexity of the pop operation in a stack is O(1) because it involves removing the top element, which is done in constant time.",
      "difficulty": "easy",
      "points": 5,
      "topic": "stacks",
      "tags": ["stack", "pop", "complexity"],
      "explanation": "The pop operation in a stack removes the top element and is performed in constant time, O(1)."
    },
    {
      "type": "interview",
      "question": "How can you implement a stack using two queues?",
      "expected_answer": "A stack can be implemented using two queues by making one queue behave like the stack. For each push operation, add elements to the first queue. For pop, transfer elements between the two queues, ensuring that the last inserted element is always at the front of the first queue.",
      "difficulty": "hard",
      "points": 15,
      "topic": "stacks",
      "tags": ["stack", "queues", "implementation"],
      "explanation": "By transferring elements between two queues, you can simulate the stack behavior where the most recent element added is always removed first."
    },
    {
      "type": "interview",
      "question": "What is the application of a stack in function call management?",
      "expected_answer": "A stack is used to manage function calls in programming. Each function call is pushed onto the stack with its local variables and return address. When the function finishes, it is popped from the stack, and control returns to the previous function.",
      "difficulty": "medium",
      "points": 10,
      "topic": "stacks",
      "tags": ["stack", "function calls", "programming"],
      "explanation": "A stack helps manage function calls by storing the local variables and return addresses, allowing the program to return control to the previous function after completion."
    },
    {
      "type": "interview",
      "question": "What is a queue?",
      "expected_answer": "A queue is a linear data structure that follows the First In, First Out (FIFO) principle, where the first element added to the queue is the first to be removed.",
      "difficulty": "medium",
      "points": 10,
      "topic": "queues",
      "tags": ["queue", "FIFO"],
      "explanation": "A queue follows the First In, First Out principle, where the first element added is the first one to be removed."
    },
    {
      "type": "interview",
      "question": "What are the main operations of a queue?",
      "expected_answer": "The main operations of a queue are enqueue (insert an element at the rear), dequeue (remove the front element), and front (peek at the front element).",
      "difficulty": "medium",
      "points": 10,
      "topic": "queues",
      "tags": ["queue", "operations", "enqueue", "dequeue", "front"],
      "explanation": "The queue operations include enqueue to add elements, dequeue to remove elements, and front to check the first element without removing it."
    },
    {
      "type": "interview",
      "question": "What is the time complexity of the enqueue and dequeue operations in a queue?",
      "expected_answer": "The time complexity of both enqueue and dequeue operations in a queue is O(1), as they both involve inserting or removing an element from either end of the queue.",
      "difficulty": "easy",
      "points": 5,
      "topic": "queues",
      "tags": ["queue", "complexity", "enqueue", "dequeue"],
      "explanation": "Both enqueue and dequeue operations are performed in constant time, O(1), as they involve adding or removing elements from the front or rear of the queue."
    },
    {
      "type": "interview",
      "question": "How do you implement a circular queue?",
      "expected_answer": "A circular queue can be implemented using a fixed-size array where the rear and front pointers wrap around when they reach the end of the array. This helps in utilizing the space efficiently.",
      "difficulty": "hard",
      "points": 15,
      "topic": "queues",
      "tags": ["queue", "circular", "implementation", "array"],
      "explanation": "A circular queue allows the rear and front pointers to wrap around, efficiently using the array space by overwriting elements once they are removed."
    },
    {
      "type": "interview",
      "question": "What is the application of a queue in breadth-first search (BFS)?",
      "expected_answer": "A queue is used in BFS to explore all nodes level by level. The nodes are enqueued when they are visited, ensuring that all nodes at the current depth are processed before moving to the next level.",
      "difficulty": "medium",
      "points": 10,
      "topic": "queues",
      "tags": ["queue", "BFS", "graph traversal"],
      "explanation": "In BFS, the queue is used to process nodes level by level, ensuring that all nodes at a particular depth are processed before proceeding to nodes at the next depth level."
    },
    {
      "type": "interview",
      "question": "What is dynamic programming?",
      "expected_answer": "Dynamic programming is a method used to solve problems by breaking them down into smaller subproblems and solving each subproblem only once, storing its solution for future reference to avoid redundant calculations.",
      "difficulty": "medium",
      "points": 10,
      "topic": "dynamic programming",
      "tags": ["dynamic programming", "problem solving", "optimization"],
      "explanation": "Dynamic programming optimizes problems by storing the results of subproblems to avoid recalculating them, ensuring efficient solutions to complex problems."
    },
    {
      "type": "interview",
      "question": "What is the difference between greedy algorithms and dynamic programming?",
      "expected_answer": "Greedy algorithms make local optimal choices at each step, while dynamic programming solves subproblems and combines their solutions to find the global optimal solution.",
      "difficulty": "medium",
      "points": 10,
      "topic": "dynamic programming",
      "tags": ["dynamic programming", "greedy algorithms", "algorithm design"],
      "explanation": "Greedy algorithms focus on local optimizations, while dynamic programming ensures global optimization by combining solutions to overlapping subproblems."
    },
    {
      "type": "interview",
      "question": "What is the time complexity of dynamic programming?",
      "expected_answer": "The time complexity of dynamic programming depends on the problem and the number of subproblems. It is generally better than a brute-force solution, but the exact time complexity depends on how many subproblems are computed and stored.",
      "difficulty": "medium",
      "points": 10,
      "topic": "dynamic programming",
      "tags": ["dynamic programming", "complexity", "optimization"],
      "explanation": "The time complexity is determined by the number of subproblems and the work done for each subproblem. Often, it is an improvement over brute-force solutions."
    },
    {
      "type": "interview",
      "question": "What is memoization in dynamic programming?",
      "expected_answer": "Memoization is a technique used in dynamic programming where the results of subproblems are stored in a table (usually an array or hash map) to avoid redundant computations.",
      "difficulty": "medium",
      "points": 10,
      "topic": "dynamic programming",
      "tags": ["dynamic programming", "memoization", "optimization"],
      "explanation": "Memoization saves intermediate results of subproblems, ensuring that each subproblem is computed only once, thus improving performance."
    },
    {
      "type": "interview",
      "question": "Can you explain the Knapsack problem?",
      "expected_answer": "The Knapsack problem is a classic dynamic programming problem where you are given a set of items, each with a weight and value, and a knapsack with a weight limit. The goal is to maximize the total value of items selected without exceeding the weight limit.",
      "difficulty": "hard",
      "points": 15,
      "topic": "dynamic programming",
      "tags": ["dynamic programming", "Knapsack problem", "optimization"],
      "explanation": "The Knapsack problem seeks the optimal selection of items under a weight constraint, using dynamic programming to explore all possible combinations efficiently."
    }
]
